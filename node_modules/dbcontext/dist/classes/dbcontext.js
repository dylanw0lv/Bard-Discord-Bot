import fs from "fs";
import DbSet from "../classes/db-set.js";
import Wait from "../utils/wait.js";
class DbContext {
    options;
    path = "./db.json";
    intervalId;
    loaded = false;
    constructor(path = "./db.json", options) {
        this.options = {
            saveInterval: options?.saveInterval || 1000 * 5,
        };
        this.path = path;
        this.load();
        this.intervalId = setInterval(async () => {
            if (!this.loaded)
                return;
            await Wait(100);
            this.save();
        }, this.options.saveInterval);
    }
    async WaitForLoad() {
        while (!this.loaded) {
            await Wait(100);
        }
    }
    getTmpPath(path) {
        if (path.indexOf(".") === -1) {
            return `${path}.tmp`;
        }
        const pathParts = path.split(".");
        const extension = pathParts.pop();
        const newPath = `${pathParts.join(".")}.tmp.${extension}`;
        return newPath;
    }
    isJSON(str) {
        try {
            JSON.parse(str);
        }
        catch (e) {
            return false;
        }
        return true;
    }
    async load() {
        let tmpFilePath = this.getTmpPath(this.path);
        if (fs.existsSync(tmpFilePath)) {
            let tmpFileData = await fs.promises.readFile(tmpFilePath, "utf8");
            if (this.isJSON(tmpFileData)) {
                await fs.promises.rename(tmpFilePath, this.path);
                console.log("Recovered from a crash.");
            }
        }
        if (!fs.existsSync(this.path)) {
            this.loaded = true;
            return;
        }
        let data = await fs.promises.readFile(this.path, "utf8");
        if (!this.isJSON(data)) {
            this.loaded = true;
            return;
        }
        let json = JSON.parse(data);
        for (let key in json) {
            this[key] = new DbSet(json[key].name, json[key].rows);
        }
        await Wait(1000);
        this.loaded = true;
    }
    async save() {
        let tmpFilePath = this.getTmpPath(this.path);
        let result = {};
        for (let key in this) {
            if (this[key] instanceof DbSet) {
                result[key] = this[key];
            }
        }
        await fs.promises.writeFile(tmpFilePath, JSON.stringify(result, null, 4));
        await fs.promises.rename(tmpFilePath, this.path);
    }
    async close() {
        clearInterval(this.intervalId);
        await this.save();
    }
}
export default DbContext;
//# sourceMappingURL=dbcontext.js.map